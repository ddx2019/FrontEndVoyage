# JavaScript的垃圾回收机制（GC）

JavaScript的垃圾回收机制是一种自动化的内存管理系统，它负责管理和释放不再被程序使用的内存空间。主要目标是识别和清理无用的数据，以便为新数据腾出空间。

这个工作机制是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。

在JavaScript中，垃圾回收器定期扫描内存，识别不再被引用的对象，并释放其所占用的内存空间，以便回收这些空间供其他变量和对象使用。这个过程是自动的，开发者不需要手动管理内存。

在现代 JavaScript 中，引擎对垃圾回收的处理方式和优化策略可能会有所不同。

关于 [Garbage collection](<https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)#Generational>)

## 常见的GC算法（策略）

### 1. 标记清除（Mark-and-Sweep）

这是JavaScript最常用的垃圾回收算法之一，现在大多数浏览器都是基于标记清除算法。

标记清除的核心思想是从根部对象出发，通过可达性分析，标记出所有能被访问到的对象，以确保不会回收仍然被引用的对象，并释放不再被引用的对象。

它通过两个阶段完成回收：

**1）标记阶段：** 从根部对象开始遍历所有被引用或可访问的对象，并标记它们。

在这个阶段，垃圾回收器将从全局对象（例如Window对象）开始，然后逐步检查和遍历这些根部对象引用的其他对象，形成一个对象图。

只有那些可以被根部对象直接或间接访问到的对象，才会被标记为可达对象，即“可到达”的对象。换句话说，如果某个对象可以通过全局对象的引用链或其他已标记对象的引用链被访问到，它就会被标记为可达对象。这些对象会被标记为活跃对象，暂时不会被回收。

在标记阶段，未被标记的对象则被视为不可达对象或不可访问对象，它们可能是之前被创建但无法通过引用链被访问到的对象。这些对象将被视为“垃圾”，在后续的清除阶段会被垃圾回收器清理并释放其所占用的内存空间。

**2）清除阶段：** 在此阶段，回收器会释放未被标记的对象所占用的内存空间。这些对象被视为无法访问，因此可以安全地被清除。

清除阶段是指垃圾回收器释放那些被标记为不可达对象（垃圾）所占用的内存空间。清除过程相对简单直接，它通过遍历整个内存空间，并释放那些未被标记的对象所占用的内存块。

这样就释放了这些不再被程序使用的内存，以便后续的变量和对象使用。这个清除过程确保了程序的内存资源能够被更有效地利用，并避免了内存泄漏问题的出现。

**缺点和优化：**

标记清除算法在进行标记和清除的过程中可能造成应用程序的停顿，因为这些操作需要遍历整个对象图。为了降低这种停顿带来的影响，现代的 JavaScript 引擎通常会优化该算法，尝试在后台进行垃圾回收，减少单次的停顿时间。

**JavaScript 示例，模拟标记清除算法的核心思想：**

这段代码模拟了标记清除算法的标记和清除两个阶段，用于展示对象的标记和清除过程。实际上，JavaScript 中的垃圾回收由引擎自动处理，开发者无法直接触发垃圾回收

```javascript

//定义一个对象
function MyObject(){
  this.reachable=false; //增加一个标记属性，表示对象是否可达
}

//递归标记可达对象

function markReachable(obj){
  if(obj.reachable) return //如果标记过，直接返回
  obj.reachable=true; //标记当前对象为可达对象

  // 模拟递归遍历对象引用的过程
  for(let key in obj){
    if(typeof obj[key]==='object'&& obj[key]!==null){
      markReachable(obj[key]) //递归标记该属性引用的对象
    }
  }
}

//创建实例对象
const myObj=new MyObject()
myObj.childObj=new MyObject() //创建子对象

//标记阶段 

markReachable(myObj) //从跟对象开始标记可达对象

// 清除阶段

function sweepUnReachable(obj){
  if(!obj.reachable){
    console.log('对象不被触达，可以被垃圾回收机制回收')
  }
  delete obj.reachable;//清除标记
  for(let key in obj){
    if(typeof obj[key]==='object'&&obj[key]!==null){
      sweepUnReachable(obj[key]);//递归清除该属性引用的对象
    }
  }
}

// 执行清除阶段
sweepUnReachable(myObj); // 从根对象开始清除不可达对象

```

### 2. 引用计数（Reference Counting）

这是挺早先的一种垃圾回收算法（现在几乎很少被使用了），它基于对象的引用计数来决定何时回收。这种方法会给每个对象附加一个引用计数器，记录着对该对象的引用次数。

**原理：**

引用计数增减： 当一个对象被赋值给一个变量时，它的引用计数加一。当该变量不再引用该对象时（比如重新赋值为其他对象、离开作用域、或手动解除引用），对象的引用计数减一。

判断对象是否成为垃圾： 引用计数为零时，垃圾回收器会认定该对象不再被程序使用，即成为垃圾对象，可以被回收。

**优点：**

- 实时性：一旦没有引用，对象就会立即被回收。

- 简单易懂：算法相对简单，易于实现。

**缺点：**

- 循环引用问题：如果两个或多个对象相互引用，即使它们已经不再被程序所使用，但由于引用计数不为零，导致它们永远不会被回收，造成了内存泄漏。
- 额外开销：维护引用计数需要额外的计算成本，每次赋值或解除引用都需要更新计数器。

在JavaScript中，引用计数不是主要的垃圾回收策略，主要因为它存在循环引用的问题，不够完善。现代的JavaScript引擎通常会选择标记清除算法作为主要的垃圾回收策略，因为它能更好地处理循环引用问题。然而，引用计数在某些环境下仍然有用，比如一些浏览器对DOM对象的垃圾回收。

****JavaScript 示例，模拟引用计数算法的核心思想：****

这段代码演示了引用计数的基本原理，即对象的引用计数随着引用的增加和减少而变化，当引用计数为 0 时表示对象不再被引用，可以被垃圾回收。但在实际 JavaScript 环境中，垃圾回收是由引擎自动管理的，开发者无法直接执行垃圾回收。

```javascript

//定义一个对象
function MyObject(){
  this.count=0;
}

//增加引用计数

MyObject.prototype.addRefrence=function (){
  this.count++;
}

//减少引用计数

MyObject.prototype.removeReference=function (){
  this.count--;
  if(this.count===0){
    console.log('对象不再被引用，可以被垃圾回收机制回收')
   // 执行垃圾回收等操作
  }
}

//创建对象实例
const myObject=new MyObject();

//增加引用计数
myObject.addRefrence()

//减少引用计数
myObject.removeRefrence()

```

## GC的缺陷及优化方法

虽然GC是自动管理内存的好工具，但它也有一些缺陷。其中一个是中断代码执行，因为它需要耗费时间来遍历和清除内存。

V8 引擎有两种优化方法：分代回收（Generation GC）和 增量 GC（increment GC）

1. 和其他语言一样 GC 会中断代码执行，停止其他操作。因为要遍历所有对象，回收所有不可访问对象。垃圾收集器通常会在进行垃圾回收时中断代码执行，这是为了确保垃圾收集器能够安全地遍历和清除内存。这个中断称为“停顿”（garbage collection pause）。
2. 分代回收：目的是减少每次GC的耗时（即可减少垃圾回收过程的总体时间）。通过对象的使用频率、存在时长区分新生代与老生代对象。多回收新生代区（young generation），少回收老生代区（tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时。
3. 增量 GC：目的是减小GC引起的中断时间。把需要长耗时的遍历、回收操作拆分运行（在执行代码的间隙逐步完成），这可以减少单次停顿的时长，但增加了回收过程的总体时间。增量 GC 的主要目标是提高程序的响应性，尤其对于大型应用程序。

### 缺陷

**停顿性：** 当垃圾回收程序运行时，它可能会中断正在执行的程序，造成一定程度的停顿或延迟。对于需要高实时性的应用，这可能导致性能问题或用户体验下降。

**性能开销：** 垃圾回收可能消耗较多的计算资源和时间。在大型应用程序中，频繁的垃圾回收可能会导致性能下降，因为它会占用大量CPU时间。

### 优化方法

**1. 增量式GC（Incremental GC）：** 将垃圾回收的过程分解成多个阶段，以减少单次回收所带来的停顿时间。这种方式可以在多个小的时间段内完成回收，减少单次停顿的影响。

**2. 分代式GC（Generational GC）：** 将内存中的对象分为不同的代（Generation），通常分为新生代和老生代。大多数对象都是短命的，所以新生代的回收频率更高。而老生代的回收频率较低，这样可以减少全局的回收次数，降低垃圾回收的性能开销。

**3. 智能化调优：** 根据具体场景和应用的内存使用情况，调整GC的参数和策略。有时候可以通过手动触发垃圾回收或调整垃圾回收的频率来优化性能。

**4. 对象复用和池化：** 在开发过程中，尽可能重用对象，减少频繁创建和销毁对象。对象池化可以在一定程度上减少内存分配和回收的次数。

**5. 并发GC（Concurrent GC）：** 一些现代的垃圾回收器支持并发执行垃圾回收操作，这样可以在不中断程序运行的情况下进行回收，减少停顿时间。

优化垃圾回收器的性能和效率需要综合考虑应用程序的特点和场景，以及对停顿时间、吞吐量等方面的需求，选择合适的优化方法。

**除了GC算法本身外，开发者也可以通过一些方法来优化内存管理：**

- 解除变量引用： 及时解除不再使用的变量引用，这不仅可以消除循环引用问题，还有助于垃圾回收器更有效地回收内存。

- 避免频繁创建全局变量： 全局变量在整个应用程序的生命周期中存在，频繁创建可能导致内存占用过高。

- 避免循环引用： 循环引用会导致对象之间相互引用，即使不再被使用，也不会被垃圾回收。

- 了解和应用垃圾回收机制对于JavaScript开发者至关重要，它有助于编写高效、节省内存的代码，并避免常见的内存泄漏问题。

这些优化方法和最佳实践能够帮助开发者更好地管理内存，减少内存泄漏的风险，提升代码性能。

## V8引擎（generational garbage collector）

V8 使用[分代垃圾收集器] 把 Javascript 堆分解成一个小的年轻代用于新分配的对象，一个大的旧代用于长生命对象（存活时间较长的对象）

**V8官方github中：** [Deep dive into V8’s garbage collection engine](https://github.com/v8/v8.dev/blob/b046176878c0ea5feee7b5d48f4f9739369174ff/src/blog/free-garbage-collection.md?plain=1#L29)

**有图文解说的掘金博客：**[isboyjc关于垃圾回收机制的博客](https://juejin.cn/post/6981588276356317214#heading-20)
